---
title: Dónde abrir el local de comidas?
author: Martin Olmos
date: '2017-11-26'
slug: donde-abrir-el-local-de-comidas
categories: []
tags: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

Hace un tiempo un amigo de un amigo me pidió ayuda para determinar cuál era el mejor lugar para abrir un local de comidas usando datos públicos disponibles. Se trataba de un servicio con modalidad 'take-away', que brindaría una oferta económica de comida saludable para el almuerzo. Básicamente, el público en el que estaba pensando era gente que trabaja en oficinas.

Lo primero que hicimos fue tratar de mapear la oferta y demanda existente. Para esto, utilizamos datos del [relevamiento de usos del suelo][1] del GCBA (que nos permitió mapear las parcelas donde funcionan oficinas) y de la API de [Yelp!](www.yelp.com), la aplicación móvil que conecta gente con negocios locales, que nos permitió obtener **información detallada de locales de comida con caractísticas similares a las del negocio analizado**.

Vamos paso por paso con el análisis que hicimos en R.
Lo primero fue cargar las librerías que vamos a utilizar. En este caso 'dplyr' y 'tidyr' para manipular los datos, 'httr' para los requerimiento a la API de Yelp! y 'leaflet' para mapear.

Luego, descargamos el relevamiento de usos del suelo y lo filtramos para quedarnos sólo con los rubros que nos interesan. A modo de muestra para este ejemplo, vamos a quedarnos con las categorías "INTERMEDIACION FINANCIERA Y AUXILIARES", "SERVICIOS DE SEGUROS Y DE ADMINISTRACION DE FONDOS DE JUBILACIONES Y PENSIONES" Y "ADMINISTRACION PUBLICA, DEFENSA Y SEGURIDAD SOCIAL" de la variable "rama1" y con la categoria "OFICINAS" de la variable "tipo_2" (para ver el detalle de lo que significa cada variable y rubro pueden referirse a la [documentación del dataset][2]).

```{r}

# Carga las librerías que vamos a necesitar
library(dplyr)
library(tidyr)
library(leaflet)
library(httr)

# Link de descarga de los datos del relevamiento de usos del suelo
usos_url <- "https://data.buenosaires.gob.ar/api/files/relevamiento-usos-del-suelo-2011.csv/download/csv"

myfile <- download.file(url = usos_url, destfile = "usos.csv", mode = "wb")
# Descarga los datos
usos <- read.csv("usos.csv", 
                   sep = ";", 
                   header = TRUE, 
                   stringsAsFactors = FALSE)

oficinas <- usos %>% filter(tipo_2 == "OFICINAS" | 
                                    rama1 == "INTERMEDIACION FINANCIERA Y AUXILIARES" | 
                                    rama1 == "ADMINISTRACION PUBLICA, DEFENSA Y SEGURIDAD SOCIAL OBLIGATORIA" | 
                                    rama1 == "SERVICIOS DE SEGUROS Y DE ADMINISTRACION DE FONDOS DE JUBILACIONES Y PENSIONES")

```

Ahora vamos por los datos de Yelp! Lo primero es crear una App en <https://yelp.co.uk/developers> y obtener un "Client ID" y un "Client Secret". Con esto podemos gestionar un token que vamos a usar para requerir los datos a la API.

Luego, tenemos que definir los parámetros de la búsqueda. En la [documentación de la API][3], vemos que hay distintos endpoints de acuerdo al tipo de información que buscamos. En nuestro caso, utilizaremos el endpoint /businesses/search (Search API) que devuelve hasta 1000 negocios de acuerdo al criterio de búsqueda. 

Los parámetros de búsqueda que utilizaremos son los siguientes:

* location: Se especifica mediante uno o varios de los siguientes elementos: dirección, barrio, ciudad, estado o código postal y país. Es el único parámetro obligatorio, salvo que se especifiquen los parámetros "latitutde" y "longitude". En nuestro caso, utilizaremos "Buenos Aires."
* categories: un listado de las categorías separadas por comas. En nuestro caso, utilizaremos "salad,vegan,vegetarian,delis,delicatessen". [Acá][4] pueden ver el listado completo de categorías.
* term: es el término de búsqueda. En nuestro caso utilizaremos el término "para llevar".
* price: Yelp! utiliza un rango de precios de cuatro escalones: 1 (barato), 2 (moderado), 3 (carito) y 4 (caro).
Los siguientes dos parámetros, limit y offset, funcionan de la siguiente manera: Supongamos que en base a una búsqueda determinada la API arroja 1200 resultados. La API sólo nos permitirá acceder a 1000, el máximo permitido, aunque no podemos acceder de una vez a todos juntos. El parámetro 'limit' especifica el número de resultados que devuelve (el default es 20 y el máximo es 50). Supongamos ahora que pido los primeros 50 resultados, para acceder a los siguientes 50, debo especificar offset = 51. Es decir, offset es el parámetro que especifica el índice del listado total de resultados a partir del cual nos va a devolver los siguientes 50.

Una vez que determinamos los parámetros hay que construir un while-loop que mientras offset sea menor a la cantidad total de negocios o menor a 1000:
* Cree un url para requerir los datos en base a los parámetros definidos
* Haga el requerimiento de los primeros 50 negocios
* Chequee si el requerimiento fue exitoso
* Transforme los resultados en un data.frame (ya que los resultados vuelven en una serie de listas anidadas)
* Actualice el valor de offset para el siguiente requerimiento

```{r}

# Descarga los datos de Yelp!
# Credenciales para la Yelp API
client_id <- "tu_client_id"
client_secret <- "tu_client_secret"

# Gestiona el token
res <- POST("https://api.yelp.com/oauth2/token",
            body = list(grant_type = "client_credentials",
                        client_id = client_id,
                        client_secret = client_secret))

token <- content(res)$access_token

# Endpoint de Yelp
yelp <- "https://api.yelp.com/v3"

# Los parámetros de búsqueda están en https://www.yelp.co.uk/developers/documentation/v3/business_search
location <- "Buenos Aires"
categories <- "salad,vegan,vegetarian,delis,delicatessen"
term <- "para llevar"
limit <- 50
offset <- 1
price <- "1,2"

# Todavía no sabemos la cantidad de resultados por lo que lo inicializamos con un valor de offset + 1
total <- offset + 1

# Crea un data.frame donde vamos a guardar los resultados
yelp_df <- data.frame()

# Loop hasta llegar al limite de 1000 resultados
while(offset < total) {
        # Construye el url de acuerdo al query deseado
        url <- modify_url(url = yelp, 
                          path = c("v3", "businesses", "search"), 
                          query = list(location = location, 
                                       limit = limit, 
                                       offset = offset, 
                                       term = term, 
                                       price = price))
        
        # Hace el requerimiento de los datos
        res <- GET(url = url, add_headers('Authorization' = paste("bearer", token)))
        
        # Chequea si el requerimiento fue exitoso
        a <- http_status(res)
        if(a$category=='Success') {
                
                # Descarga el contenido
                b <- content(res)
                
                # Lo convierte en un data.frame
                c <- do.call("rbind", lapply(b$businesses, function(x) {
                        return(as.data.frame(t(as.matrix(x))))}))
                yelp_df <- rbind(yelp_df, c)
                
                # Actualiza el número de resultados totales
                total <- b$total
                
                # Actualiza el valor de 'offset'
                offset = offset + 50
                
        } else {
                break()
        }
        
}
```

Finalmente, tenemos que lidiar con algunos inconvenientes relacionados a cómo vienen estructurados los resultados. Si observamos las variables 'categories', 'coordinates' y 'location' vemos que necesitan limpieza, ya que son listas que contienen algunos elementos que son necesarios y otros que no. 

Empecemos con 'categories', que tiene por cada categoría un 'Title' y un 'Alias'. En esta instancia sólo nos interesa el 'Title', por lo que lo vamos a extraer y luego la transformamos de 'list' a 'character' y eliminamos los signos de puntuación (excepto por las comas y los espacios que nos sirven para separar las categorías).

En el caso de la variable 'coordinates' hay que hacer algo similar. Empezamos por convertirla a 'character' y eliminamos los caracteres que quedaron como resabio del tipo 'list'. Luego, separamos la columna en 'lat' y 'long' y eliminamos las palabras 'latitude' y 'longitude'.

Con respecto a 'location', también es una lista con varios elementos. En este caso, nos vamos a quedar sólo con la dirección ('address'), y luego lo convertimos a 'character'.

Finalmente, hay que convertir cada variable de 'list' a 'character', excepto por 'lat' y 'long' que tienen que ser 'numeric'. 

```{r}
# Extrae el 'Title' de cada categoría
cat_title <- lapply(yelp_df$categories, function(x) {
        sapply(x, function(y) {
                return(y$title)
        })
})
# Elimina los signos de puntuación, excepto por los espacios y las comas
yelp_df$categories <- as.character(cat_title) %>% 
        gsub(pattern = "c\\(", replacement = "") %>%
        gsub(pattern =  "[^[:alnum:][:space:],]", replacement = "")


# Convierte a 'character' y elimina los caracteres resabio del tipo 'list'
yelp_df$coordinates <- yelp_df$coordinates %>% 
        as.character() %>% 
        gsub(pattern = "list\\(|\\)", replacement = "")

# Separa la variable 'coordinates' en 'lat' y 'long'
yelp_df <- separate(data = yelp_df, col = coordinates, into = c("lat", "long"), sep = ", ")

# Elimina la palabra 'latitude'
yelp_df$lat <- yelp_df$lat %>% 
        gsub(pattern = "latitude = ", replacement = "")

# Elimina la palabra 'longitude'
yelp_df$long <- yelp_df$long %>% 
        gsub(pattern = "longitude = ", replacement = "")

# Extrae 'address' de 'location'
address_yelp <- lapply(yelp_df$location, function(x) {
        return(x$address1[1])
})

# Convierte a 'character'
yelp_df$location <- as.character(address_yelp)

# Convierte cada columna (excepto 'lat' y 'long') en character y el objeto en dataframe
yelp_df <- apply(yelp_df, 2, as.character)
yelp_df <- as.data.frame(yelp_df, stringsAsFactors = FALSE)
yelp_df$lat <- as.numeric(yelp_df$lat)
yelp_df$long <- as.numeric(yelp_df$long)

```

Ahora sólo falta mapear, tanto la oferta como la demanda. Para esto vamos a utilizar la librería 'leaflet' para crear mapas interactivos. La demanda la vamos a presentar 'clusterizada' aprovechando opciones de clusterización propias de 'leaflet' que demarcan la zona del cluster, mientras que para la oferta vamos a utilizar 'markers' simples (puntos rojos) que al pasarles el puntero por encima nos muestran el nombre del negocio de comidas. 

```{r}

leaflet() %>% 
        addTiles() %>% 
        addMarkers(data = oficinas, 
                   lng = ~x, 
                   lat = ~y, 
                   clusterOptions = markerClusterOptions()) %>%
        addCircleMarkers(data = yelp_df, 
                         lng = ~long, 
                         lat = ~lat, 
                         label = ~name, 
                         radius = 0.5,
                         color = 'red',
                         fillOpacity = 1)


```

Un ejemplo similar pero usando [Shiny][5] para seleccionar las categorías de la demanda lo vemos acá:

<iframe src="https://martinolmos.shinyapps.io/App_Garat/" style="border: none; width: 1000px; height: 1000px"></iframe>

[1]:https://data.buenosaires.gob.ar/dataset/relevamiento-usos-del-suelo
[2]:https://data.buenosaires.gob.ar/api/files/documentacion-relevamiento-usos-suelo-2011.pdf/download
[3]:https://www.yelp.co.uk/developers/documentation/v3
[4]:https://www.yelp.co.uk/developers/documentation/v2/all_category_list
[5]:https://shiny.rstudio.com/